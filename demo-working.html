<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Working Sticky Container Demo</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
    }

    .demo-container {
      max-width: 800px;
      margin: 0 auto;
    }

    .section {
      margin-bottom: 30px;
      padding: 20px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal {
      background: white;
      border-radius: 8px;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      padding: 20px;
      border-bottom: 1px solid #eee;
      flex-shrink: 0;
    }

    .modal-body {
      flex: 1;
      overflow-y: auto;
      padding: 0;
    }

    .modal-content {
      padding: 20px;
    }

    .scroll-container {
      height: 300px;
      border: 2px solid #ddd;
      border-radius: 4px;
      overflow-y: auto;
      background: #f9f9f9;
      position: relative;
    }

    .content-spacer {
      height: 150px;
      background: linear-gradient(to bottom, #e8f4fd, #b8e6ff);
      margin: 10px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      font-weight: bold;
    }

    .sticky-element {
      background: #4CAF50;
      color: white;
      padding: 15px;
      margin: 10px;
      border-radius: 4px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .sticky-element.is-sticky {
      background: #ff9800;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transform: scale(1.02);
    }

    .long-content {
      height: 800px;
      background: linear-gradient(to bottom, #fff3e0, #ffcc80);
      margin: 10px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #333;
      font-weight: bold;
    }

    .code-block {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 15px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      overflow-x: auto;
      margin: 15px 0;
    }

    .status {
      padding: 10px;
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
      margin: 15px 0;
    }

    .button {
      background: #2196f3;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }

    .button:hover {
      background: #1976d2;
    }

    .hidden {
      display: none;
    }

    .problem-demo .sticky-element {
      background: #f44336;
    }

    .solution-demo .sticky-element {
      background: #4CAF50;
    }
  </style>
</head>

<body>
  <div class="demo-container">
    <h1>üîß Sticky Container - Working Solutions</h1>

    <div class="section">
      <h2>‚ùå Problem: Using Selector When Element is Inside Container</h2>
      <p>This is the <strong>incorrect</strong> way that causes issues:</p>
      <div class="code-block">
        // ‚ùå WRONG: StickyContainer is inside .modal-body, but tries to use it as container
        &lt;div className="modal-body"&gt;
        &lt;StickyContainer
        container=".modal-body" // ‚ùå Can't find parent when queried from inside
        direction="top"
        &gt;
        Sticky Header
        &lt;/StickyContainer&gt;
        &lt;/div&gt;
      </div>

      <button class="button" onclick="showProblemDemo()">Show Problem Demo</button>

      <div id="problem-demo" class="modal-overlay hidden">
        <div class="modal">
          <div class="modal-header">
            <h3>‚ùå Problem Demo - Selector Inside Container</h3>
            <button class="button" onclick="hideProblemDemo()">Close</button>
          </div>
          <div class="modal-body" id="problem-modal-body">
            <div class="modal-content">
              <div class="content-spacer">Content before sticky</div>

              <div class="sticky-element problem-demo" id="problem-sticky">
                ‚ùå This won't stick properly to modal (using selector ".modal-body")
                <div class="status" id="problem-status">Status: Not sticky</div>
              </div>

              <div class="long-content">
                Long scrollable content...<br>
                Scroll to see the problem!<br>
                The sticky element doesn't stick to the modal top.
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>‚úÖ Solution 1: Using Ref</h2>
      <p>The <strong>correct</strong> way using React ref:</p>
      <div class="code-block">
        // ‚úÖ CORRECT: Using ref to pass container element
        const modalBodyRef = useRef&lt;HTMLDivElement&gt;(null);

        &lt;div className="modal-body" ref={modalBodyRef}&gt;
        &lt;StickyContainer
        container={modalBodyRef.current} // ‚úÖ Direct element reference
        direction="top"
        &gt;
        Sticky Header
        &lt;/StickyContainer&gt;
        &lt;/div&gt;
      </div>

      <button class="button" onclick="showSolutionDemo()">Show Working Demo</button>

      <div id="solution-demo" class="modal-overlay hidden">
        <div class="modal">
          <div class="modal-header">
            <h3>‚úÖ Working Demo - Using Element Reference</h3>
            <button class="button" onclick="hideSolutionDemo()">Close</button>
          </div>
          <div class="modal-body" id="solution-modal-body">
            <div class="modal-content">
              <div class="content-spacer">Content before sticky</div>

              <div class="sticky-element solution-demo" id="solution-sticky">
                ‚úÖ This sticks properly to modal top (using element ref)
                <div class="status" id="solution-status">Status: Ready</div>
              </div>

              <div class="long-content">
                Long scrollable content...<br>
                Scroll to see it working!<br>
                The sticky element sticks to the modal top correctly.
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>üìã Best Practices</h2>
      <div class="status">
        <strong>Key Rules:</strong>
        <ul>
          <li>‚úÖ Use <code>useRef</code> or <code>useState</code> to pass container element</li>
          <li>‚úÖ Avoid selectors when StickyContainer is inside the target container</li>
          <li>‚úÖ Use callback refs for dynamic containers</li>
          <li>‚úÖ Set proper <code>containerOffset</code> for spacing</li>
          <li>‚ùå Don't use <code>container=".parent"</code> when sticky is inside <code>.parent</code></li>
        </ul>
      </div>

      <h3>React Implementation Examples:</h3>

      <div class="code-block">
        // ‚úÖ Method 1: useRef
        const containerRef = useRef&lt;HTMLDivElement&gt;(null);

        &lt;div ref={containerRef} className="scroll-container"&gt;
        &lt;StickyContainer
        container={containerRef.current}
        direction="top"
        containerOffset={{ top: 10 }}
        &gt;
        Sticky Content
        &lt;/StickyContainer&gt;
        &lt;/div&gt;
      </div>

      <div class="code-block">
        // ‚úÖ Method 2: useState with callback ref
        const [container, setContainer] = useState&lt;HTMLDivElement | null&gt;(null);

        &lt;div ref={setContainer} className="scroll-container"&gt;
        &lt;StickyContainer
        container={container}
        direction="top"
        &gt;
        Sticky Content
        &lt;/StickyContainer&gt;
        &lt;/div&gt;
      </div>

      <div class="code-block">
        // ‚úÖ Method 3: External container (selector is OK)
        // When StickyContainer is NOT inside the target container
        &lt;div className="page-container"&gt;
        &lt;div className="sidebar"&gt;
        &lt;StickyContainer
        container=".page-container" // ‚úÖ OK: external container
        direction="top"
        &gt;
        Sticky Sidebar
        &lt;/StickyContainer&gt;
        &lt;/div&gt;
        &lt;/div&gt;
      </div>
    </div>
  </div>

  <script>
    // –ü—Ä–æ—Å—Ç–∞—è —Å–∏–º—É–ª—è—Ü–∏—è sticky behavior –¥–ª—è –¥–µ–º–æ
    class StickySimulator {
      constructor(element, container, statusElement) {
        this.element = element;
        this.container = container;
        this.statusElement = statusElement;
        this.isSticky = false;
        this.originalTop = 0;

        this.init();
      }

      init() {
        // –ü–æ–ª—É—á–∞–µ–º –∏–∑–Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é —ç–ª–µ–º–µ–Ω—Ç–∞
        this.updateOriginalPosition();

        // –°–ª—É—à–∞–µ–º —Å–∫—Ä–æ–ª–ª –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        this.container.addEventListener('scroll', () => this.handleScroll());

        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –ø—Ä–∏ —Ä–µ—Å–∞–π–∑–µ
        window.addEventListener('resize', () => this.updateOriginalPosition());
      }

      updateOriginalPosition() {
        const containerRect = this.container.getBoundingClientRect();
        const elementRect = this.element.getBoundingClientRect();
        this.originalTop = elementRect.top - containerRect.top + this.container.scrollTop;
      }

      handleScroll() {
        const containerRect = this.container.getBoundingClientRect();
        const scrollTop = this.container.scrollTop;
        const threshold = this.originalTop;

        const shouldStick = scrollTop >= threshold;

        if (shouldStick !== this.isSticky) {
          this.isSticky = shouldStick;
          this.updateElement();
        }

        this.updateStatus();
      }

      updateElement() {
        if (this.isSticky) {
          this.element.classList.add('is-sticky');
          this.element.style.position = 'sticky';
          this.element.style.top = '10px';
          this.element.style.zIndex = '10';
        } else {
          this.element.classList.remove('is-sticky');
          this.element.style.position = '';
          this.element.style.top = '';
          this.element.style.zIndex = '';
        }
      }

      updateStatus() {
        const scrollPercent = Math.round((this.container.scrollTop / (this.container.scrollHeight - this.container.clientHeight)) * 100);
        this.statusElement.textContent = `Status: ${this.isSticky ? 'STICKY!' : 'Normal'} | Scroll: ${scrollPercent}%`;
      }
    }

    let problemSticky = null;
    let solutionSticky = null;

    function showProblemDemo() {
      document.getElementById('problem-demo').classList.remove('hidden');

      // –°–∏–º—É–ª–∏—Ä—É–µ–º –ø—Ä–æ–±–ª–µ–º—É - sticky –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ
      setTimeout(() => {
        const element = document.getElementById('problem-sticky');
        const container = document.getElementById('problem-modal-body');
        const status = document.getElementById('problem-status');

        // –°–∏–º—É–ª–∏—Ä—É–µ–º –ø–æ–ª–æ–º–∞–Ω–Ω—ã–π sticky (–æ—Å—Ç–∞–µ—Ç—Å—è –Ω–∞ –º–µ—Å—Ç–µ)
        problemSticky = {
          handleScroll: () => {
            const scrollPercent = Math.round((container.scrollTop / (container.scrollHeight - container.clientHeight)) * 100);
            status.textContent = `Status: ‚ùå Broken (selector issue) | Scroll: ${scrollPercent}%`;
            // –≠–ª–µ–º–µ–Ω—Ç –Ω–µ –ø—Ä–∏–ª–∏–ø–∞–µ—Ç!
          }
        };

        container.addEventListener('scroll', problemSticky.handleScroll);
      }, 100);
    }

    function hideProblemDemo() {
      document.getElementById('problem-demo').classList.add('hidden');
      if (problemSticky) {
        const container = document.getElementById('problem-modal-body');
        container.removeEventListener('scroll', problemSticky.handleScroll);
      }
    }

    function showSolutionDemo() {
      document.getElementById('solution-demo').classList.remove('hidden');

      // –°–∏–º—É–ª–∏—Ä—É–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞—é—â–∏–π sticky
      setTimeout(() => {
        const element = document.getElementById('solution-sticky');
        const container = document.getElementById('solution-modal-body');
        const status = document.getElementById('solution-status');

        solutionSticky = new StickySimulator(element, container, status);
      }, 100);
    }

    function hideSolutionDemo() {
      document.getElementById('solution-demo').classList.add('hidden');
      solutionSticky = null;
    }

    // –ó–∞–∫—Ä—ã—Ç–∏–µ –º–æ–¥–∞–ª–æ–≤ –ø–æ –∫–ª–∏–∫—É –Ω–∞ overlay
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-overlay')) {
        hideProblemDemo();
        hideSolutionDemo();
      }
    });
  </script>
</body>

</html>
